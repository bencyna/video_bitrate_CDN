#!/usr/bin/env python3
import threading

from socket import *
import sys
def closeConnections(clientSocket, serverSocket):
    clientSocket.close()
    serverSocket.close()
    print("Closed connections")
    
def sendMessage(message, socket):
    data_to_send = "".join(message).encode()
    socket.sendall(data_to_send) 

def receiveMessageHeader(socket):  
    buffer = ""
    # get headers
    while True:
        data = socket.recv(1024).decode()
        print("data coming in recv: ", data)
        buffer += data
        if "\r\n\r\n" in buffer:
            break
          
    # Separate headers from the rest of the message
    headers_data, body = buffer.split("\r\n\r\n", 1)
    headers_data += "\r\n\r\n"
    
    print(headers_data)
    return headers_data, body

def receiveMessageServer(socket):
    header, body = receiveMessageHeader(socket)
    print("message from server header",header)
    print("message from server body",body)
    # read the content length 
    # receive into body until the content length reached
    message = header.extend(body)
    return message


def connectToServer(fake_ip, server_ip):
    # bind to a server
    serverSocket = socket(AF_INET, SOCK_STREAM)
    serverSocket.bind((fake_ip, 0))
    
    # connect to the server
    serverSocket.connect((server_ip, 80))
    print("Connected to server")
    
    return serverSocket

   
def runProxy(clientSocket, serverSocket):
    while True:
        # receive message from the client
        # read the header
        header, _ = receiveMessageHeader(clientSocket)
        
        # forward message to server
        print("sending header to server")
        sendMessage(header, serverSocket)
    
        # receive messages from server 
        server_message = receiveMessageServer(serverSocket)
        
        # read header
        # receive message until the whole chunk has arrived
        # log the messages in format <time> <duration> <server-ip> <chunkname> <chunk-size>
        
        # send the full message to the client
        
        # repeat 
        
        # if the client closes the connection, close the connection, close the file and return
 
       
def handle_client(clientSocket, log_file, fake_ip):
    # write to log file
    f = open(log_file, "a")
    f.write("Client opened connection\n")
    # establish connection to recieve messages from the client
    # establish connection to the server
    serverSocket = connectToServer(fake_ip, server_ip)
    
    
    runProxy(clientSocket, serverSocket)
    
    
#Main
if __name__ == "__main__":
    if len(sys.argv) != 5:
        print("Usage: python3", sys.argv[0], "<log>", "<listen-port>", "<fake-ip>", "<server-ip>")
        sys.exit()
        
    log_file = str(sys.argv[1])
    listen_port = int(sys.argv[2])    
    fake_ip = str(sys.argv[3])    
    server_ip = str(sys.argv[4])    
    print("log path: ", log_file, "Listen Port:", listen_port, "Fake IP:", fake_ip, "Server IP:", server_ip)

    proxySocket = socket(AF_INET, SOCK_STREAM)

    proxySocket.bind(("", listen_port))

    proxySocket.listen(5)
    
    # continuously listen for client
    while True:
        client_socket, client_address = proxySocket.accept()
        print(f"Client connected, starting thread")
        # Spin up a new thread to handle the client
        threading.Thread(target=handle_client, args=(client_socket, log_file, fake_ip)).start()
        