#!/usr/bin/env python3
import threading

from socket import *
import sys
def closeConnections(clientSocket, serverSocket):
    clientSocket.close()
    serverSocket.close()
    print("Closed connections")
    
def sendMessage(message, socket):
    data_to_send = "".join(message).encode()
    print("message: ", "".join(message))
    socket.sendall(data_to_send) 

def receiveMessage(socket):  
    headers = []
    buffer = ""
    while True:
        data = client_socket.recv(1024).decode('utf-8')
        print(data)
        buffer += data
        if "\r\n\r\n" in buffer:
            break

    # Separate headers from the rest of the message
    headers_data, body = buffer.split("\r\n\r\n", 1)

    # Split headers into individual lines
    headers = headers_data.split("\r\n")
    
    # Print out the request line and headers
    print("Request Line:", headers[0])  
    print("Headers:")
    for header in headers[1:]:  # Iterate over the remaining lines (the headers)
        key, value = header.split(":", 1)
        print(f"{key.strip()}: {value.strip()}")  # Strip to clean up whitespace
    
    return headers, body

def connectToServer(fake_ip, server_ip):
    # bind to a server
    serverSocket = socket(AF_INET, SOCK_STREAM)
    serverSocket.bind((fake_ip, 0))
    
    # connect to the server
    serverSocket.connect((server_ip, 80))
    print("Connected to server")
    
    return serverSocket

   
def runProxy(clientSocket, serverSocket):
    # receive message from the client
    while True:
        header, body = receiveMessage(clientSocket)
        
        # read the header
        # get the number of bits needed for the byte
        # recv on loop until the number of bits is reached
    
    # receive messages from server 
    # read header
    # receive message until the whole chunk has arrived
    # log the messages in format <time> <duration> <server-ip> <chunkname> <chunk-size>
    
    # send the full message to the client
    
    # repeat 
    
    # if the client closes the connection, close the connection, close the file and return
 
       
def handle_client(clientSocket, log_file, fake_ip):
    # write to log file
    f = open(log_file, "a")
    f.write("Client opened connection\n")
    # establish connection to recieve messages from the client
    # establish connection to the server
    serverSocket = connectToServer(fake_ip, server_ip)
    
    runProxy(clientSocket, serverSocket)
    
    
#Main
if __name__ == "__main__":
    if len(sys.argv) != 5:
        print("Usage: python3", sys.argv[0], "<log>", "<listen-port>", "<fake-ip>", "<server-ip>")
        sys.exit()
        
    log_file = str(sys.argv[1])
    listen_port = int(sys.argv[2])    
    fake_ip = str(sys.argv[3])    
    server_ip = str(sys.argv[4])    
    print("log path: ", log_file, "Listen Port:", listen_port, "Fake IP:", fake_ip, "Server IP:", server_ip)

    proxySocket = socket(AF_INET, SOCK_STREAM)

    proxySocket.bind(("", listen_port))

    proxySocket.listen(5)
    
    # continuously listen for client
    while True:
        client_socket, client_address = proxySocket.accept()
        print(f"Client connected, starting thread")
        # Spin up a new thread to handle the client
        threading.Thread(target=handle_client, args=(client_socket, log_file, fake_ip)).start()
        