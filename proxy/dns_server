#!/usr/bin/env python3

import struct
import sys
from socket import *

import struct

import struct

def create_dns_response(data, ip_address):
   # Parse the domain name from the query
    domain_name = parse_dns_query(data)
    id = data[:2]  # Transaction ID
    flags = b'\x81\x80'  # Standard response with no errors
    questions = b'\x00\x01'  # One question
    answers = b'\x00\x01'  # One answer
    authority = b'\x00\x00'  # No authority records
    additional = b'\x00\x00'  # No additional records
    header = id + flags + questions + answers + authority + additional

    # Encode domain name for question section
    domain = encode_domain_name(domain_name)
    q_type = b'\x00\x01'  # Type A (host address)
    q_class = b'\x00\x01'  # Class IN (internet)
    question_section = domain + q_type + q_class

    # Answer section
    answer_name = b'\xc0\x0c'  # Pointer to domain name in the question section
    ttl = struct.pack('!I', 300)  # TTL set to 300 seconds
    length = b'\x00\x04'  # IPv4 address length
    addr = inet_aton(ip_address)  # Convert IP address to binary
    answer_section = answer_name + q_type + q_class + ttl + length + addr

    # Combine all parts into the final response
    response = header + question_section + answer_section

    return response

def parse_dns_query(data):
    domain_start = 12  # Queries start after the 12-byte header
    domain_name = []
    while True:
        length = data[domain_start]
        if length == 0:  # End of domain name
            break
        domain_start += 1
        domain_name.append(data[domain_start:domain_start + length].decode('utf-8'))
        domain_start += length
    return '.'.join(domain_name)

def encode_domain_name(domain_name):
    labels = domain_name.split('.')
    encoded_name = b''
    for label in labels:
        encoded_name += bytes([len(label)]) + label.encode('utf-8')
    return encoded_name + b'\x00'  # Null byte to terminate




if __name__ == "__main__":
    if len(sys.argv) != 5:
        print("Usage: python3", sys.argv[0], "<topo-dir>", "log", "<listen-port>", "decision-method>")
        sys.exit()
        
    topo_dir = str(sys.argv[1])
    log_file = str(sys.argv[2])
    listen_port = int(sys.argv[3])
    decision_method = str(sys.argv[4])
    ip_addr = "5.0.0.1"
    topo_dns_file = topo_dir + '/topo' + topo_dir[-1] + ".dns"
    topo_servers = topo_dir + '/topo' + topo_dir[-1] + ".servers"
    
    with open(topo_dns_file, "r") as file:
        ip_addr = file.read().strip()
        
    server_ip_responses = []
    with open(topo_servers, "r") as file:
        server_ip_responses = [x for x in file.read().split("\n") if x]
    
    print("topo_dir:", topo_dir, "log_file:", log_file, "listen_port:", listen_port, "decision_method:", decision_method, "ip-addr:", ip_addr)
    
    server_socket = socket(AF_INET, SOCK_DGRAM)
    server_socket.bind((ip_addr, listen_port))
    
    try:
        while True:
            data, client_address = server_socket.recvfrom(512)
            print(f"Received message from {client_address}: {data}")
            response = create_dns_response(data, ip_addr)
            server_socket.sendto(response, client_address)
            
    except KeyboardInterrupt:
        print("\nServer is shutting down.")
    finally:
        server_socket.close()

    
      
