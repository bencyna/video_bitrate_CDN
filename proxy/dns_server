#!/usr/bin/env python3

import struct
import sys
from socket import *

import struct

def create_dns_response(query_data, ip_address="192.0.2.1"):
    # Parse the transaction ID from the query (first 2 bytes)
    transaction_id = query_data[:2]
    
    # Flags: Response (QR=1), Standard Query (OPCODE=0), No Error (RCODE=0)
    flags = struct.pack("!H", 0x8180)  # 1000 0001 1000 0000 in binary

    # Question Count (QDCOUNT) is 1
    qdcount = struct.pack("!H", 1)

    # Answer Count (ANCOUNT) is 1 (we're providing one answer)
    ancount = struct.pack("!H", 1)

    # NSCOUNT and ARCOUNT are 0 (no additional or authority records)
    nscount = struct.pack("!H", 0)
    arcount = struct.pack("!H", 0)

    # DNS Header
    header = transaction_id + flags + qdcount + ancount + nscount + arcount

    # Question Section: Echo back the question section from the query
    question_section = query_data[12:]  # Skipping the header (first 12 bytes)

    # Answer Section
    # Name: Pointer to the domain name in the question section (0xC00C means offset 12)
    name = struct.pack("!H", 0xC00C)
    
    # Type: A (IPv4 address)
    type_ = struct.pack("!H", 1)
    
    # Class: IN (Internet)
    class_ = struct.pack("!H", 1)
    
    # TTL: 300 seconds (5 minutes)
    ttl = struct.pack("!I", 300)
    
    # Data length: 4 bytes (IPv4 address)
    data_len = struct.pack("!H", 4)
    
    # Hardcoded IP Address (e.g., "192.0.2.1")
    ip_parts = map(int, ip_address.split("."))
    ip_bytes = struct.pack("!4B", *ip_parts)

    # Combine all parts to form the answer section
    answer_section = name + type_ + class_ + ttl + data_len + ip_bytes

    # Combine header, question section, and answer section
    response = header + question_section + answer_section

    return response


def parse_dns_query(data):
    # DNS Header is the first 12 bytes
    transaction_id, flags, qdcount, ancount, nscount, arcount = struct.unpack("!6H", data[:12])

    # Print the header info
    print(f"Transaction ID: {transaction_id}")
    print(f"Flags: {flags}")
    print(f"Questions: {qdcount}, Answer RRs: {ancount}, Authority RRs: {nscount}, Additional RRs: {arcount}")

    # Parsing the Question Section
    question_offset = 12
    domain_name = []
    while True:
        length = data[question_offset]
        if length == 0:
            question_offset += 1
            break
        domain_name.append(data[question_offset + 1: question_offset + 1 + length].decode())
        question_offset += length + 1

    domain_name = ".".join(domain_name)
    print(f"Domain Name: {domain_name}")

    # Extract query type and class (next 4 bytes after domain name)
    qtype, qclass = struct.unpack("!2H", data[question_offset:question_offset + 4])
    print(f"Query Type: {qtype}, Query Class: {qclass}")

    return {
        "transaction_id": transaction_id,
        "flags": flags,
        "qdcount": qdcount,
        "ancount": ancount,
        "nscount": nscount,
        "arcount": arcount,
        "domain_name": domain_name,
        "query_type": qtype,
        "query_class": qclass
    }



if __name__ == "__main__":
    if len(sys.argv) != 5:
        print("Usage: python3", sys.argv[0], "<topo-dir>", "log", "<listen-port>", "decision-method>")
        sys.exit()
        
    topo_dir = str(sys.argv[1])
    log_file = str(sys.argv[2])
    listen_port = int(sys.argv[3])
    decision_method = str(sys.argv[4])
    ip_addr = "5.0.0.1"
    topo_dns_file = topo_dir + '/topo' + topo_dir[-1] + ".dns"
    topo_servers = topo_dir + '/topo' + topo_dir[-1] + ".servers"
    
    with open(topo_dns_file, "r") as file:
        ip_addr = file.read().strip()
        
    server_ip_responses = []
    with open(topo_servers, "r") as file:
        server_ip_responses = [x for x in file.read().split("\n") if x]
    
    print("topo_dir:", topo_dir, "log_file:", log_file, "listen_port:", listen_port, "decision_method:", decision_method, "ip-addr:", ip_addr)
    
    server_socket = socket(AF_INET, SOCK_DGRAM)
    server_socket.bind((ip_addr, listen_port))
    
    try:
        while True:
            data, client_address = server_socket.recvfrom(512)
            print(f"Received message from {client_address}: {data}")
            parse_dns_query(data)
            response = create_dns_response(data, ip_address=server_ip_responses[0])
            server_socket.sendto(response, client_address)
            
    except KeyboardInterrupt:
        print("\nServer is shutting down.")
    finally:
        server_socket.close()

    
      
